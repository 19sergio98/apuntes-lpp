<!DOCTYPE html>  
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
  <title>seminario1-scheme</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style id="mkstylesheet">
/*! normalize.css v3.0.3 | MIT License | github.com/necolas/normalize.css */html{font-family:sans-serif;-webkit-text-size-adjust:100%;-ms-text-size-adjust:100%;text-size-adjust:100%}body{margin:0}article,aside,details,figcaption,figure,footer,header,hgroup,main,menu,nav,section,summary{display:block}audio,canvas,progress,video{display:inline-block;vertical-align:baseline}audio:not([controls]){display:none;height:0}[hidden],template{display:none}a{background-color:transparent}a:active,a:hover{outline:0}abbr[title]{border-bottom:1px dotted}b,strong{font-weight:bold}dfn{font-style:italic}h1{font-size:2em;margin:0.67em 0}mark{background:#ff0;color:#000}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sup{top:-0.5em}sub{bottom:-0.25em}img{border:0}svg:not(:root){overflow:hidden}figure{margin:1em 40px}hr{box-sizing:content-box;height:0}pre{overflow:auto}code,kbd,pre,samp{font-family:monospace, monospace;font-size:1em}button,input,optgroup,select,textarea{color:inherit;font:inherit;margin:0}button{overflow:visible}button,select{text-transform:none}button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}button[disabled],html input[disabled]{cursor:default}button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}input{line-height:normal}input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}input[type="number"]::-webkit-inner-spin-button,input[type="number"]::-webkit-outer-spin-button{height:auto}input[type="search"]{-webkit-appearance:textfield;box-sizing:content-box}input[type="search"]::-webkit-search-cancel-button,input[type="search"]::-webkit-search-decoration{-webkit-appearance:none}fieldset{border:1px solid #c0c0c0;margin:0 2px;padding:0.35em 0.625em 0.75em}legend{border:0;padding:0}textarea{overflow:auto}optgroup{font-weight:bold}table{border-collapse:collapse;border-spacing:0}td,th{padding:0}*{box-sizing:border-box}input,select,textarea,button{font:13px/1.4 Helvetica,arial,nimbussansl,liberationsans,freesans,clean,sans-serif,"Segoe UI Emoji","Segoe UI Symbol"}body{font:13px/1.4 Helvetica, arial, nimbussansl, liberationsans, freesans, clean, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol";color:#333;background-color:#fff}a{color:#4078c0;text-decoration:none}a:hover,a:active{text-decoration:underline}hr,.rule{height:0;margin:15px 0;overflow:hidden;background:transparent;border:0;border-bottom:1px solid #ddd}hr:before,.rule:before{display:table;content:""}hr:after,.rule:after{display:table;clear:both;content:""}h1,h2,h3,h4,h5,h6{margin-top:15px;margin-bottom:15px;line-height:1.1}h1{font-size:30px}h2{font-size:21px}h3{font-size:16px}h4{font-size:14px}h5{font-size:12px}h6{font-size:11px}small{font-size:90%}blockquote{margin:0}ul,ol{padding:0;margin-top:0;margin-bottom:0}ol ol,ul ol{list-style-type:lower-roman}ul ul ol,ul ol ol,ol ul ol,ol ol ol{list-style-type:lower-alpha}dd{margin-left:0}tt,code{font-family:Consolas, "Liberation Mono", Menlo, Courier, monospace;font-size:12px}pre{margin-top:0;margin-bottom:0;font:12px Consolas,"Liberation Mono",Menlo,Courier,monospace}html,body{color:black}#wrapper{font:16px helvetica,arial,freesans,clean,sans-serif;-webkit-font-smoothing:antialiased;line-height:1.6;padding:3px;background:#fff;border-radius:3px;-moz-border-radius:3px;-webkit-border-radius:3px;border:solid 1px #dddddd !important;color:#333}p{margin:1em 0}a{color:#4183c4;text-decoration:none}#wrapper{background-color:#fff;padding:30px;margin:15px;font-size:16px;line-height:1.6}#wrapper>*:first-child{margin-top:0 !important}#wrapper>*:last-child{margin-bottom:0 !important}@media screen{#wrapper{border:solid 1px #ddd}}h1,h2,h3,h4,h5,h6{position:relative;margin-top:1em;margin-bottom:16px;font-weight:700;line-height:1.4;color:#333}h1{padding-bottom:.3em;font-size:2.25em;line-height:1.2;border-bottom:1px solid #eee}h2{padding-bottom:0.3em;font-size:1.75em;line-height:1.225;border-bottom:1px solid #eee}h3{font-size:1.5em;line-height:1.43}h4{font-size:1.25em}h5{font-size:1em}h6{color:#777;font-size:1em}p,blockquote,ul,ol,dl,table,pre{margin-top:0;margin-bottom:16px}hr{height:4px;padding:0;margin:16px 0;background-color:#e7e7e7;border:0 none}ul,ol{padding-left:2em}ul.no-list,ol.no-list{padding:0;list-style-type:none}ul ul,ul ol{margin-top:0;margin-bottom:0}ol ol,ol ul{margin-top:0;margin-bottom:0}li>p{margin-top:16px}dl{padding:0}dl dt{padding:0;margin-top:16px;font-size:1em;font-style:italic;font-weight:700}dl dd{padding:0 16px;margin-bottom:16px}blockquote{padding:0 15px;margin-left:0;color:#777;border-left:4px solid #ddd}blockquote>:first-child{margin-top:0}blockquote>:last-child{margin-bottom:0}table{display:block;width:100%;overflow:auto}table th{font-weight:700;padding:6px 13px;border:1px solid #ddd}table td{padding:6px 13px;border:1px solid #ddd}table tr{background-color:#fff;border-top:1px solid #ccc}table tr:nth-child(2n){background-color:#f8f8f8}img{max-width:100%;-moz-box-sizing:border-box;box-sizing:border-box}span.frame{display:block;overflow:hidden}span.frame>span{display:block;float:left;width:auto;padding:7px;margin:13px 0 0;overflow:hidden;border:1px solid #ddd}span.frame span img{display:block;float:left}span.frame span span{display:block;padding:5px 0 0;clear:both;color:#333}span.align-center{display:block;overflow:hidden;clear:both}span.align-center>span{display:block;margin:13px auto 0;overflow:hidden;text-align:center}span.align-center span img{margin:0 auto;text-align:center}span.align-right{display:block;overflow:hidden;clear:both}span.align-right>span{display:block;margin:13px 0 0;overflow:hidden;text-align:right}span.align-right span img{margin:0;text-align:right}span.float-left{display:block;float:left;margin-right:13px;overflow:hidden}span.float-left span{margin:13px 0 0}span.float-right{display:block;float:right;margin-left:13px;overflow:hidden}span.float-right>span{display:block;margin:13px auto 0;overflow:hidden;text-align:right}code,tt{padding:0;padding-top:.2em;padding-bottom:.2em;margin:0;font-size:85%;background-color:rgba(0,0,0,0.04);border-radius:3px}code:before,code:after{letter-spacing:-.2em;content:"\00a0"}tt:before,tt:after{letter-spacing:-.2em;content:"\00a0"}code br,tt br{display:none}del code{text-decoration:inherit;vertical-align:text-top}pre>code{padding:0;margin:0;font-size:100%;white-space:pre;background:transparent;border:0}.highlight{margin-bottom:16px}.highlight pre{padding:16px;margin-bottom:0;overflow:auto;font-size:85%;line-height:1.45;background-color:#f7f7f7;border-radius:3px}pre{padding:16px;margin-bottom:16px;overflow:auto;font-size:85%;line-height:1.45;background-color:#f7f7f7;border-radius:3px;word-wrap:normal}pre code,pre tt{display:inline;max-width:initial;padding:0;margin:0;overflow:initial;line-height:inherit;word-wrap:normal;background-color:transparent;border:0}pre code:before,pre code:after{content:normal}pre tt:before,pre tt:after{content:normal}.poetry pre{font-family:Georgia, Garamond, serif !important;font-style:italic;font-size:110% !important;line-height:1.6em;display:block;margin-left:1em}.poetry pre code{font-family:Georgia, Garamond, serif !important;word-break:break-all;word-break:break-word;-webkit-hyphens:auto;-moz-hyphens:auto;hyphens:auto;white-space:pre-wrap}sup,sub,a.footnote{font-size:1.4ex;height:0;line-height:1;vertical-align:super;position:relative}sub{vertical-align:sub;top:-1px}@media print{body{background:#fff}img,table,figure{page-break-inside:avoid}#wrapper{background:#fff;border:none !important;font-size:12px}pre code{overflow:visible}}@media screen{body.inverted{color:#eee !important;border-color:#555;box-shadow:none}.inverted #wrapper,.inverted hr,.inverted p,.inverted td,.inverted li,.inverted h1,.inverted h2,.inverted h3,.inverted h4,.inverted h5,.inverted h6,.inverted th,.inverted .math,.inverted caption,.inverted dd,.inverted dt,.inverted blockquote{color:#eee !important;border-color:#555;box-shadow:none}.inverted td,.inverted th{background:#333}.inverted pre,.inverted code,.inverted tt{background:#eeeeee !important;color:#111}.inverted h2{border-color:#555555}.inverted hr{border-color:#777;border-width:1px !important}::selection{background:rgba(157,193,200,0.5)}h1::selection{background-color:rgba(45,156,208,0.3)}h2::selection{background-color:rgba(90,182,224,0.3)}h3::selection,h4::selection,h5::selection,h6::selection,li::selection,ol::selection{background-color:rgba(133,201,232,0.3)}code::selection{background-color:rgba(0,0,0,0.7);color:#eeeeee}code span::selection{background-color:rgba(0,0,0,0.7) !important;color:#eeeeee !important}a::selection{background-color:rgba(255,230,102,0.2)}.inverted a::selection{background-color:rgba(255,230,102,0.6)}td::selection,th::selection,caption::selection{background-color:rgba(180,237,95,0.5)}.inverted{background:#0b2531;background:#252a2a}.inverted #wrapper{background:#252a2a}.inverted a{color:#acd1d5}}.highlight{background:#fff}.highlight .c{color:#998;font-style:italic}.highlight .err{color:#a61717;background-color:#e3d2d2}.highlight .k,.highlight .o{font-weight:700}.highlight .cm{color:#998;font-style:italic}.highlight .cp{color:#999;font-weight:700}.highlight .c1{color:#998;font-style:italic}.highlight .cs{color:#999;font-weight:700;font-style:italic}.highlight .gd{color:#000;background-color:#fdd}.highlight .gd .x{color:#000;background-color:#faa}.highlight .ge{font-style:italic}.highlight .gr{color:#a00}.highlight .gh{color:#999}.highlight .gi{color:#000;background-color:#dfd}.highlight .gi .x{color:#000;background-color:#afa}.highlight .go{color:#888}.highlight .gp{color:#555}.highlight .gs{font-weight:700}.highlight .gu{color:purple;font-weight:700}.highlight .gt{color:#a00}.highlight .kc,.highlight .kd,.highlight .kn,.highlight .kp,.highlight .kr{font-weight:700}.highlight .kt{color:#458;font-weight:700}.highlight .m{color:#099}.highlight .s{color:#d14}.highlight .n{color:#333}.highlight .na{color:teal}.highlight .nb{color:#0086b3}.highlight .nc{color:#458;font-weight:700}.highlight .no{color:teal}.highlight .ni{color:purple}.highlight .ne,.highlight .nf{color:#900;font-weight:700}.highlight .nn{color:#555}.highlight .nt{color:navy}.highlight .nv{color:teal}.highlight .ow{font-weight:700}.highlight .w{color:#bbb}.highlight .mf,.highlight .mh,.highlight .mi,.highlight .mo{color:#099}.highlight .sb,.highlight .sc,.highlight .sd,.highlight .s2,.highlight .se,.highlight .sh,.highlight .si,.highlight .sx{color:#d14}.highlight .sr{color:#009926}.highlight .s1{color:#d14}.highlight .ss{color:#990073}.highlight .bp{color:#999}.highlight .vc,.highlight .vg,.highlight .vi{color:teal}.highlight .il{color:#099}.highlight .gc{color:#999;background-color:#EAF2F5}.type-csharp .highlight .k,.type-csharp .highlight .kt{color:blue}.type-csharp .highlight .nf{color:#000;font-weight:400}.type-csharp .highlight .nc{color:#2b91af}.type-csharp .highlight .nn{color:#000}.type-csharp .highlight .s,.type-csharp .highlight .sc{color:#a31515}.type-csharp .highlight .k,.type-csharp .highlight .kt{color:#00F}.type-csharp .highlight .nf{color:#000;font-weight:normal}.type-csharp .highlight .nc{color:#2B91AF}.type-csharp .highlight .nn{color:#000}.type-csharp .highlight .s,.type-csharp .highlight .sc{color:#A31515}body.dark #wrapper{background:transparent !important;box-shadow:none !important}
#mkreplaced-toc{list-style-position:inside;padding:0;margin:0 0 0 1rem;list-style-type:none}#mkreplaced-toc li::before{content:''}#mkreplaced-toc li{font-size:1.5rem;line-height:1.5;font-weight:normal}#mkreplaced-toc li ul{font-size:1.3rem;font-weight:300;padding:.5rem 0;margin:0 0 0 1rem}#mkreplaced-toc li.missing{list-style-type:none !important}#mkreplaced-toc.max-1 ul,#mkreplaced-toc.max1 ul{display:none}#mkreplaced-toc.max-2 ul ul,#mkreplaced-toc.max2 ul ul{display:none}#mkreplaced-toc.max-3 ul ul ul,#mkreplaced-toc.max3 ul ul ul{display:none}#mkreplaced-toc.max-4 ul ul ul ul,#mkreplaced-toc.max4 ul ul ul ul{display:none}#mkreplaced-toc.max-5 ul ul ul ul ul,#mkreplaced-toc.max5 ul ul ul ul ul{display:none}.rtl{direction:rtl;text-align:right}@media print{body{background:white;line-height:1.4}html,body,#wrapper{max-width:100%;width:100%;-webkit-text-size-adjust:none;-webkit-perspective:none !important;box-sizing:border-box;width:auto;border:0;margin:0;padding:0;float:none;-moz-box-shadow:none !important;-webkit-box-shadow:none !important;box-shadow:none !important}mark{background:transparent !important}h1,h2,h3,h4,h5,h6{page-break-after:avoid}p,h2,h3{orphans:3;widows:3}section{page-break-before:avoid}#generated-toc,#firstdiff,#toc-title,#mkdocumentprogress,#mkincludechart,#mkprogressbar1,#mkprogressbar2,.mkscrollmeter,#alllinks,.popup{display:none !important}.suppressprintlinks a{color:inherit !important;text-decoration:none !important;border-bottom:none !important;cursor:default !important}.hrefafterlinktext #wrapper a:link:after,.hrefafterlinktext #wrapper a:visited:after{content:" (" attr(href) ") ";font-size:90%;opacity:0.9}.nocodebreak pre{page-break-inside:avoid}img,table,figure{page-break-inside:avoid}.breakfootnotes .footnotes{page-break-before:always}.breakfootnotes .footnotes hr{display:none}#mktoctitle{display:block}#print-title{display:block;border-bottom:solid 1px #666}#wrapper pre{white-space:pre;white-space:pre-wrap;word-wrap:break-word}#wrapper #generated-toc-clone,#wrapper #mkreplaced-toc{display:block}.task-list .task-list-item{list-style-type:none !important}.task-list .task-list-item-checkbox{-webkit-appearance:none;position:relative}.task-list .task-list-item-checkbox:before{content:' ';border:solid 1px #aaa;width:1em;height:1em;display:block;border-radius:2px;left:-20px;top:-1em;position:absolute}}
#wrapper #generated-toc-clone, #wrapper #mkreplaced-toc, #wrapper #generated-toc-clone ul, #wrapper #mkreplaced-toc ul {
    list-style-position: inside;
}
#wrapper #generated-toc-clone li.missing, #wrapper #mkreplaced-toc li.missing {
    list-style-type: none!important;
}
#wrapper #generated-toc-clone, #wrapper #mkreplaced-toc {
    list-style-type: upper-roman;
}
#wrapper #generated-toc-clone>li>ul, #wrapper #mkreplaced-toc>li>ul  {
    list-style-type: decimal;
}
#wrapper #generated-toc-clone>li>ul>li>ul, #wrapper #mkreplaced-toc>li>ul>li>ul {
    list-style-type: decimal-leading-zero;
}
#wrapper #generated-toc-clone>li>ul>li>ul>li>ul, #wrapper #mkreplaced-toc>li>ul>li>ul>li>ul {
    list-style-type: lower-greek;
}
#wrapper #generated-toc-clone>li>ul>li>ul>li>ul>li>ul, #wrapper #mkreplaced-toc>li>ul>li>ul>li>ul>li>ul {
    list-style-type: disc;
}
#wrapper #generated-toc-clone>li>ul>li>ul>li>ul>li>ul>li>ul, #wrapper #mkreplaced-toc>li>ul>li>ul>li>ul>li>ul>li>ul {
    list-style-type: square;
}
#wrapper #generated-toc-clone,#wrapper #mkreplaced-toc{list-style-position:outside!important;margin-left:2rem;}
</style>

<style id="mkprintstyles">@media print{#wrapper #generated-toc-clone,#generated-toc{display:none!important;}
html,body,#wrapper{font-size:10pt!important;}
}
</style>


</head>
<body class="normal firstload">
  <div id="wrapper">
      <h2 id="seminario1:seminariodescheme">Seminario 1: Seminario de Scheme</h2>

<h3 id="bibliografía">Bibliografía</h3>

<p>Este seminario está basado en los siguientes materiales. Os recomendamos que los leáis y, si os interesa y os queda tiempo, que exploréis también en los enlaces que hemos dejado en los apuntes para ampliar información.</p>

<ul>
<li><a href="http://racket-lang.org/">DrRacket</a>, <a href="http://docs.racket-lang.org/drracket/index.html">Entorno de programación DrRacket</a></li>
<li><em>R6RS</em> <a href="http://www.r6rs.org/final/r6rs.pdf">(pdf)</a>
<a href="https://docs.racket-lang.org/r6rs/">(html)</a></li>
<li><a href="http://www.eecs.berkeley.edu/~bh/ss-toc2.html">Simply Scheme</a></li>
</ul>

<h3 id="ellenguajedeprogramaciónscheme">El lenguaje de programación Scheme</h3>

<p>Scheme es un lenguaje de programación que surgió en los laboratorios del MIT en 1975, cuando Guy L. Steele y Gerarld J. Sussman buscaban un lenguaje con una semántica muy clara y sencilla. Pensaban que los lenguajes no se deberían desarrollar añadiendo muchas características, sino quitando las debilidades y las limitaciones que hacen que las características adicionales parezcan necesarias. Scheme es un dialecto de Lisp, es un lenguaje interpretado, muy expresivo y soporta varios paradigmas. Estuvo influenciado por el cálculo lambda. El desarrollo de Scheme ha sido lento, ya que la gente que estandarizó Scheme es muy conservadora en cuanto a añadirle nuevas características,porque la calidad ha sido siempre más importante que la utilidad empresarial. Por eso Scheme es considerado como uno de los lenguajes mejor diseñados de propósito general. Aprender Scheme hará que seáis mejores programadores cuando utilicéis otros lenguajes de programación.</p>

<h4 id="elentornodeprogramacióndrracket">El entorno de programación DrRacket</h4>

<p>Cuando lanzamos DrRacket, vemos que tiene tres partes: una fila de botones arriba, dos paneles de edición en el medio y una barra de estado abajo.</p>

<figure>
<img src="imagenes/racket1.png" alt="" />
</figure>

<p>El panel de edición superior es la ventana de definiciones. Se utiliza para implementar funciones, como la función square en el ejemplo. El panel inferior, llamado <em>ventana de interacción</em>, se utiliza para evaluar expresiones interactivamente. Pulsando el botón <em>Run</em>, se evalúa el programa de la <em>ventana de definiciones</em>, haciendo que esas definiciones estén disponibles en la ventana de interacción. Así, dada la definición de <code>square</code>, después de pulsar <em>Run</em>, podemos teclear la expresión <code>(square 2)</code> en la <em>ventana de interacción</em>, se evaluará y mostrará el resultado, en este caso 4.</p>

<h4 id="cambiarelidiomadelentorno">Cambiar el idioma del entorno</h4>

<p>Podemos interactuar con el entorno en el idioma que queramos. Si queremos tenerlo por ejemplo en español, vamos al menú <em>Help -&gt; Interactúa con DrRacket en español</em>. Nos aparecerá un diálogo que nos obligará a reiniciar el intérprete para aceptar los cambios.</p>

<figure>
<img src="imagenes/racket2.png" alt="" />
</figure>

<h4 id="eligiendounlenguaje">Eligiendo un lenguaje</h4>

<p>DrRacket soporta muchos dialectos de Scheme, entre los cuales se encuentra su primera versión estándar IEEE, llamada <em>R5RS</em> (<em>Revised 5 Report on the Algorithmic Language Scheme</em>), que aparece en el año 1998. Nosotros vamos a utilizar la siguiente versión <em>R6RS</em> (2007). Para ello, cuando arranquemos DrRacket, debemos hacer lo siguiente:</p>

<ol>
<li><p>Asegurarnos que en la parte inferior de la ventana aparece &#8220;<em>Determine language from source</em>&#8221;</p></li>
<li><p>En el panel de edición debemos escribir las siguientes líneas:</p>
<pre><code class="(null)">#lang r6rs
(import (rnrs base))</code></pre></li>
<li><p>Finalmente pulsar el botón <em>Run</em> (Ejecutar) para que se cargue ese lenguaje en el intérprete.</p></li>
</ol>

<figure>
<img src="imagenes/racket3.png" alt="" />
</figure>

<p><strong>Aclaraciones:</strong></p>
<pre><code class="(null)">#lang r6rs</code></pre>

<p>es una directiva de DrRacket que determina qué lenguaje será interpretado</p>
<pre><code class="(null)">(import (rnrs base))</code></pre>

<p>importar una librería en el lenguaje r6rs. En este caso, la librería con las funciones básicas del lenguaje. Además de ésta, en la asignatura usaremos otras librerías que se indicarán en los correspondientes enunciados de las prácticas cuando sean necesarias.</p>

<h3 id="ellenguajescheme">El lenguaje Scheme</h3>

<h4 id="vamosaempezarprobandoalgunosejemplos">Vamos a empezar probando algunos ejemplos</h4>

<p>Scheme es un lenguaje interpretado. Vamos a lanzar DrRacket y teclear en la ventana de interacción algunas expresiones. El intérprete analizará la expresión y mostrará el valor resultante de evaluarla.</p>

<pre><code>2
(+ 2 3)
(+)
(+ 2 4 5 6)
(+ (* 2 3) (- 3 1))
</code></pre>

<p>Las expresiones en Scheme tienen una forma denominada <em>notación prefija de Cambridge</em> (el nombre de Cambridge es por la localidad Cambridge, Massachusets, donde reside el MIT, lugar en el que se ideó el Lisp), en la que la expresión está delimitada por paréntesis y el operador va seguido de los operandos. La sintaxis es la siguiente:</p>

<pre><code>(&lt;función&gt; &lt;arg1&gt; ... &lt;argn&gt;)
</code></pre>

<p>En Scheme podemos interpretar los paréntesis abiertos ‘(’ como evaluadores o lanzadores de la función que hay a continuación. La forma que tiene Scheme de evaluar una expresión es muy sencilla:</p>

<ol>
<li><p>Evalúa cada uno de los argumentos</p></li>
<li><p>Aplica la función nombrada tras el paréntesis a los valores resultantes de la evaluación anterior</p>

<pre><code>(+ (* 2 3) (- 3 (/ 12 3)))
⇒ (+ 6 (- 3 (/ 12 3)))
⇒ (+ 6 (- 3 4))
⇒ (+ 6 -1)
⇒ 5
</code></pre></li>
</ol>

<p>En Scheme los términos función y procedimiento significan lo mismo y se usan de forma intercambiable. Son ejemplos de funciones o procedimientos: +, -, *. En Scheme la evaluación de una función siempre devuelve un valor, a no ser que se produzca un error que detiene la evaluación:</p>

<pre><code>(* (+ 3 4) (/ 3 0))
</code></pre>

<h4 id="definiendovariablesyfunciones">Definiendo variables y funciones</h4>

<p>Podemos utilizar en el intérprete la forma especial <code>define</code> para definir variables y funciones. En clase de teoría veremos cómo es el funcionamiento del <code>define</code>, pero por el momento lo utilizaremos para definir variables asociadas a valores, e implementar funciones o procedimientos. Scheme es un lenguaje multiparadigma pero principalmente funcional, y una de sus características principales es que los programas se construyen mediante la definición de funciones.</p>

<p>Definimos variables en la ventana de interacción:</p>

<pre><code>(define pi 3.14159)
pi
(sin (/ pi 2))
(define a (+ 2 (* 3 4)))
a
</code></pre>

<p>Para implementar una función también se utiliza define, con la siguiente sintaxis:</p>

<pre><code>(define (&lt;nombre-funcion&gt; &lt;args&gt;)
    &lt;cuerpo-funcion&gt;
)
</code></pre>

<p>Por ejemplo, vamos a implementar una función que toma dos números como parámetros y devuelve la suma de sus cuadrados:</p>

<pre><code>(define (suma-cuadrados x y)
    (+ (* x x) (* y y)))
(suma-cuadrados 2 3)  ; ⇒ 13
</code></pre>

<p>Podemos comprobar una característica muy importante de Scheme. Se trata de un lenguaje débilmente tipeado, en el que los argumentos <code>x</code> e <code>y</code> no tienen tipo. Si se invoca a la función pasando algún dato que no sea un número, el intérprete no detectará ningún error hasta que el momento en que se intente evaluar la multiplicación. Lo podemos comprobar con el siguiente ejemplo:</p>

<pre><code>(suma-cuadrados 10 &quot;hola&quot;)
</code></pre>

<p>Veremos más adelante que hay distintos tipos de números, y la función definida va a funcionar bien para todos ellos. En el ejemplo anterior hemos pasado como parámetro números enteros. Podemos pasar números reales:</p>

<pre><code>(suma-cuadrados 2.4 5.8)  ; ⇒ 39.4
</code></pre>

<p>o fracciones:</p>

<pre><code>(suma-cuadrados (/ 2 3) (/ 3 5))  ; ⇒ 181/225
</code></pre>

<h4 id="algunasprimitivas">Algunas primitivas</h4>

<p>Las primitivas de Scheme consisten en un conjunto de tipos de datos, formas especiales y funciones incluidas en el lenguaje. A lo largo del curso iremos introduciendo estas primitivas. Las primitivas básicas del lenguaje están descritas en las 30 páginas del apartado 11 (<em>Base library</em>) del manual de referencia del R6RS.</p>

<p>Vamos a revisar los tipos de datos primitivos de Scheme, así como algunas funciones primitivas para trabajar con valores de esos tipos.</p>

<ul>
<li>Booleanos</li>
<li>Números</li>
<li>Caracteres</li>
<li>Cadenas</li>
<li>Parejas</li>
<li>Listas</li>
</ul>

<p>Estos dos últimos los veremos en detalle en futuras clases, cuando hablemos de tipos de datos compuestos.</p>

<h5 id="booleanos">Booleanos</h5>

<p>Un booleano es un valor de verdad, que puede ser verdadero o falso. En Scheme, tenemos los símbolos #t y #f para expresar verdadero y falso respectivamente, pero en muchas operaciones se considera que cualquier valor distinto de #f es verdadero. Ejemplos:</p>

<pre><code>#t
#f
(&gt; 3 1.5)
(= 3 3.0)
(equal? 3 3.0)
(or (&lt; 3 1.5) #t)
(and #t #t #f)
(not #f)
(not 3)
</code></pre>

<h5 id="números">Números</h5>

<p>La cantidad de tipos numéricos que soporta Scheme es grande, incluyendo enteros de diferente precisión, números racionales, complejos e inexactos.</p>

<h6 id="algunasprimitivassobrenúmeros">Algunas primitivas sobre números</h6>

<pre><code>(&lt;= 2 3 3 4 5)
(max 3 5 10 1000)
(/ 22 4)  ; Devuelve una fracción
(div 22 4)
(mod 22 4)
(equal? 0.5 (/ 1 2))
(= 0.5 (/ 1 2))
(abs (* 3 -2))
(sin 2.2) ; relacionados: cos, tan, asin, acos, ata
</code></pre>

<h6 id="primitivasquedevuelvennúmerosinexactos">Primitivas que devuelven números inexactos</h6>

<pre><code>(floor x) devuelve el entero más grande no mayor que x
(ceiling x) devuelve el entero más pequeño no menor que x
(truncate x) devuelve el entero más cercano a x cuyo valor absoluto no es mayor que el valor absoluto de x
(round x) devuelve el entero más cercano a x, redondeado
(floor -4.3)    ; ⇒ -5.0
(floor 3.5)     ; ⇒ 3.0
(ceiling -4.3)  ; ⇒ -4.0
(ceiling 3.5)   ; ⇒ 4.0
(truncate -4.3) ; ⇒ -4.0
(truncate 3.5)  ; ⇒ 3.0
(round -4.3)    ; ⇒ -4.0
(round 3.5)     ; ⇒ 4.0
</code></pre>

<h6 id="operacionessobrenúmeros">Operaciones sobre números</h6>

<pre><code>(number? 1)
(integer? 2.3)
(integer? 4.0)
(real? 1)
(positive? -4)
(negative? -4)
(zero? 0.2)
(even? 2)
(odd? 3)
</code></pre>

<h5 id="caracteres">Caracteres</h5>

<p>Se soportan caracteres internacionales y se codifican en UTF&#8211;8.</p>

<pre><code>#\a
#\A
#\space
#\ñ
#\á        
</code></pre>

<h5 id="operacionessobrecaracteres">Operaciones sobre caracteres</h5>

<pre><code>(char&lt;? #\a #\b)
(char-numeric? \#1)
(char-alphabetic? #\3)
(char-whitespace? #\space)
(char-upper-case? #\A)
(char-lower-case? #\a)
(char-upcase #\ñ)
(char-&gt;integer #\space)
(integer-&gt;char 32) ;#\space
(char-&gt;integer (integer-&gt;char 5000))
</code></pre>

<h5 id="cadenas">Cadenas</h5>

<p>Las cadenas son secuencias finitas de caracteres.</p>

<pre><code>&quot;hola&quot;
&quot;La palabra \&quot;hola\&quot; tiene 4 letras&quot;
</code></pre>

<h6 id="constructoresdecadenas">Constructores de cadenas</h6>

<pre><code>(make-string 5 #\o) ⇒ &quot;ooooo&quot;
(string #\h #\o #\l #\a) ⇒ &quot;hola&quot;
</code></pre>

<h6 id="operacionesconcadenas">Operaciones con cadenas</h6>

<pre><code>(substring &quot;Hola que tal&quot; 2 4)
(string? &quot;hola&quot;)
(string-&gt;list &quot;hola&quot;)
(string-length &quot;hola&quot;)
(string-ref &quot;hola&quot; 0)
(string-append &quot;hola&quot; &quot;adios&quot;)
</code></pre>

<h6 id="comparadoresdecadenas">Comparadores de cadenas</h6>

<pre><code>(string=? &quot;Hola&quot; &quot;hola&quot;)
(string=? &quot;hola&quot; &quot;hola&quot;)
(string&lt;? &quot;aab&quot; &quot;cde&quot;)
(string&gt;=? &quot;www&quot; &quot;qqq&quot;)
</code></pre>

<h4 id="parejas">Parejas</h4>

<p>Elemento fundamental de Scheme. Es un tipo compuesto formado por dos elementos (no necesariamente del mismo tipo).</p>

<pre><code>(cons 1 2)        ; cons crea una pareja
(cons #t 3)       ; elementos de tipos diferentes
(car (cons &quot;hola&quot; 2))  ; elemento izquierdo
(cdr (cons &quot;bye&quot; 5))   ; elemento derecho
</code></pre>

<p>Cuando evaluamos las expresiones anteriores en el intérprete, Scheme muestra el resultado de construir la pareja con la sintaxis:</p>

<pre><code>{elemento izquierdo . elemento derecho}
</code></pre>

<p>Por ejemplo:</p>

<pre><code>(cons 1 2) ; ⇒ {1 . 2}
</code></pre>

<p>Scheme es un lenguaje débilmente tipeado y las variables y parejas pueden contener cualquier tipo de dato. Incluso otras parejas:</p>

<pre><code>(define p1 (cons 1 2)) ; definimos una pareja formada por 1 y 2
(cons p1 3)            ; definimos una pareja formada por la pareja (1 . 2) y 3
                       ; ⇒ {{1 . 2} . 3}
(cons (cons 1 2) 3)    ; igual que la expresión anterior
                       ; ⇒ {{1 . 2} . 3}
</code></pre>

<p>Hay veces que el trabajo de imprimir una pareja no es tan sencillo para Scheme. Si la pareja está en la parte derecha de la pareja principal el intérprete imprime esto, que no se corresponde con lo que esperamos:</p>

<pre><code>(cons 1 (cons 2 3)) ; ⇒ {1 2 . 3}
</code></pre>

<p>Más adelante explicaremos por qué.</p>

<h4 id="listas">Listas</h4>

<p>Uno de los elementos fundamentales de Scheme, y de Lisp, son las listas. Es un tipo compuesto formado por un conjunto finito de elementos (no necesariamente del mismo tipo). Vamos a ver cómo definir, crear, recorrer y concatenar listas:</p>

<p>Podemos crear una lista con la función <code>list</code>:</p>

<pre><code>(list 1 2 3 4)     ;list crea una lista
</code></pre>

<p>El intérprete de Scheme R6RS muestra las listas entre llaves:</p>

<pre><code>(list 1 2 3 4) ;  ⇒ {1 2 3 4}
</code></pre>

<p>Otra forma de definir una lista es con la <em>forma especial</em> <code>quote</code> (que se representa con una tilde <code>'</code>) al comienzo de elementos entre paréntesis:</p>

<pre><code>'(1 2 3 4)         ; otra forma de definir la misma lista
</code></pre>

<p>Veremos más adelante la diferencia entre la función <code>list</code> y la forma especial <code>quote</code>. </p>

<p>La forma más básica de trabajar con una lista es usando las funciones <code>car</code> para obtener su primer elemento y <code>cdr</code> para obtener el resto de la lista. Son las mismas funciones de las parejas, pero ahora se aplican a listas. También veremos más adelante por qué estas funciones pueden trabajar tanto sobre parejas como sobre listas.</p>

<pre><code>(car '(1 2 3 4))   ; ⇒ 1
(cdr '(1 2 3 4))   ; ⇒ {2 3 4} 
</code></pre>

<p>El <code>cdr</code> de una lista siempre devuelve otra lista. El <code>cdr</code> de una lista de un elemento es la <em>lista vacía</em>, que en Scheme se representa con <code>()</code>:</p>

<pre><code>(cdr '(1))  ; ⇒ () lista vacía
</code></pre>

<p>La función <code>null?</code> comprueba si una lista es vacía. Es el caso base de gran parte de funciones recursivas que recorren listas.</p>

<pre><code>(null? (cdr '(1))) ; ⇒ #t
</code></pre>

<p>Podemos construir una nueva lista añadiendo un elemento a la cabeza de una lista existente usando la función <code>cons</code> (también la misma función sobre pareja, ya explicaremos también por qué) usando como parámetro un elemento y una lista:</p>

<pre><code>(cons elemento lista) 
</code></pre>

<p>Por ejemplo:</p>

<pre><code>(cons 1 '(2 3 4 5)) ; ⇒ {1 2 3 4 5}
(cons 1 '())       ; ⇒ {1} 
(cons 1 (cons 2 '())) ; ⇒ {1 2} 
</code></pre>

<p>También podemos usar la función <code>append</code> para concatenar varias listas</p>

<pre><code>(append '(1) '(2 3 4) '(5 6)) ; ⇒ {1 2 3 4 5 6}
</code></pre>

<p>Igual que las parejas, las listas pueden contener distintos tipos de datos:</p>

<pre><code>(list &quot;hola&quot; &quot;que&quot; &quot;tal&quot;) ; ⇒ {&quot;hola&quot; &quot;que&quot; &quot;tal&quot;} lista de cadenas
(cons &quot;hola&quot; '(1 2 3 4))  ; ⇒ {&quot;hola&quot; 1 2 3 4} lista de distintos tipos de datos
</code></pre>

<p>Una lista puede incluso contener otras listas:</p>

<pre><code>(list (list 1 2) 3 4 (list 5 6))   ; lista que contiene listas
⇒ {{1 2} 3 4 {5 6}} 
(cons (list 1 2) '(3 4 5)) ; nueva lista añadiendo una lista
⇒ {{1 2} 3 4 5}}
(list (cons 1 2) (cons 3 4))  ; lista que contiene parejas
⇒ {{1 . 2} {3 . 4}}
</code></pre>

<p>En clase de teoría estudiaremos con más profundidad las listas en Scheme, cómo están implementadas y cómo se utilizan para crear otras estructuras de datos más complejas como árboles. Para este seminario de introducción es suficiente con estas funciones básicas que nos permiten crear, combinar y obtener elementos de listas.</p>

<h3 id="estructurasdecontrol">Estructuras de control</h3>

<p>Como en cualquier lenguaje de programación, las estructuras de control en Scheme nos permiten seleccionar qué parte de una expresión evaluamos en función de la evaluación de una expresión condicional. Las estructuras de control las veremos con más detenimiento en las clases de teoría, ahora por el momento vamos a ver ejemplos de funcionamiento.</p>

<p>En Scheme tenemos dos tipos de estructuras de control: <code>if</code> y <code>cond</code>.</p>

<h4 id="if">if</h4>

<p>Realiza una evaluación condicional de las expresiones que la siguen, según el resultado de una condición. Una expresión <code>if</code> tiene siempre cuatro elementos: el propio <code>if</code>, la condición, la expresión que se evalúa si la condición es verdadera y la expresión que se evalúa si la expresión es falsa:</p>

<pre><code>(if (&gt; 2 3) &quot;2 es mayor que 3&quot; &quot;2 es menor o igual que 3&quot;)
</code></pre>

<p>Al escribir código en Scheme es habitual colocar el <code>if</code> y la condición en una línea y las otras dos expresiones en las siguientes líneas:</p>

<pre><code>(if (&gt; 2 3)
    &quot;2 es mayor que 3&quot;
    &quot;2 es menor o igual que 3&quot;)
</code></pre>

<p>En las expresiones que devuelven el valor cuando la condición es cierta o falsa se puede escribir cualquier expresión de Scheme, incluido otro <code>if</code>:</p>

<pre><code>(if (&gt; 2 3)
    (if (&lt; 10 5)
        &quot;2 es mayor que 3 y 10 es menor que 5&quot;
        &quot;2 es mayor que 3 y 10 es mayor o igual que 5&quot;)
    &quot;2 es menor o igual que 3&quot;)
</code></pre>

<p>Un ejemplo en el que vemos una función que contiene un <code>if</code>. La siguiente función de tres argumentos devuelve la suma de los últimos si el primero es positivo o la resta en caso contrario:</p>

<pre><code>(define (suma-si-x-positivo x y z)
    (if (&gt;= x 0)
        (+ y z)
        (- y z)))

(suma-si-x-positivo 2 3 5) ; ⇒ 8
(suma-si-x-positivo -3 3 5) ; ⇒ -2
</code></pre>

<h4 id="cond">cond</h4>

<p>Cuando tenemos un conjunto de alternativas o para evitar usar ifs anidados.
<code>cond</code> evalúa una serie de condiciones y devuelve el valor de la expresión asociada a la primera condición verdadera.</p>

<pre><code>(cond
    ((&gt; 3 4) “3 es mayor que 4”)
    ((&lt; 2 1) “2 es menor que 1”)
    ((&gt; 3 2) “3 es mayor que 2”)
    (else “ninguna condicion es cierta”))
</code></pre>

<h3 id="comentarios">Comentarios</h3>

<p>Para comentar una línea de código en la ventana de definiciones, se escribe el símbolo punto y coma <code>;</code> al comienzo de la línea.
Si queremos comentar más de una línea, podemos utilizar el menú de DrRacket: seleccionamos las líneas a comentar y pinchamos en la opción Racket -&gt; comentar con punto y coma.</p>

<h3 id="ejemploscompletos">Ejemplos completos</h3>

<h4 id="raízdesegundogrado">Raíz de segundo grado</h4>

<p>Vamos a resolver la ecuación de segundo grado en Scheme. Vamos a implementar el procedimiento <code>(ecuacion a b c)</code> que devuelva una pareja con las dos raíces de la solución. Nos vamos a ayudar de funciones auxiliares.</p>

<p>Recordamos la fórmula:</p>

<p><span class="math">\[x = {-b \pm \sqrt{b^2-4ac} \over 2a}\]</span></p>

<p>Implementamos la solución de forma modular. Primer definimos la función que define el discriminante:</p>

<pre><code>(define (discriminante a b c)
    (- (* b b) (* 4 a c)))
</code></pre>

<p>Después definimos las funciones que devuelven la raíz positiva y la raíz negativa, usando la función <code>discriminante</code> anterior:</p>

<pre><code>(define (raiz-pos a b c)
    (/ (+ (* b -1) (sqrt (discriminante a b c))) (* 2 a)))

(define (raiz-neg a b c)
    (/ (- (* b -1) (sqrt (discriminante a b c))) (* 2 a)))
</code></pre>

<p>Por último, definimos la función <code>ecuacion</code> que invoca a las funciones anteriores y devuelve una pareja con los valores resultantes:</p>

<pre><code>(define (ecuacion a b c)
    (cons (raiz-pos a b c) (raiz-neg a b c)))
</code></pre>

<p>Lo probamos:</p>

<pre><code>(ecuacion 1 -5 6)
{3 . 2}
(ecuacion 2 -7 3)
{3 . 1/2}
(ecuacion -1 7 -10)
{2 . 5}
</code></pre>

<h4 id="conversióndegradoscelsiusafarenheit">Conversión de grados Celsius a Farenheit</h4>

<p>Vamos a definir una función llamada <code>convertir-temperatura</code> que permite realizar una conversión de grados Fahrenheit a Centígrados o vicerversa.</p>

<p>La función toma dos argumentos, el primero será un número que representa los grados y el segundo será un carácter (<code>F</code> o <code>C</code>) que indica la unidad de medida en la que están expresados los grados.</p>

<p>Las fórmulas de conversión son las siguientes:</p>

<p><span class="math">\[C = (F - 32) * 5/9\]</span></p>

<p><span class="math">\[F = (C * 9/5) + 32\]</span></p>

<p>Primero definimos unas funciones auxiliares que calculan las expresiones anteriores:</p>
<pre><code class="(null)">(define (a-grados-fahrenheit grados-centigrados)
  (+ (* (/ 9 5) grados-centigrados) 32))

(define (a-grados-centigrados grados-fahrenheit)
  (* (/ 5 9) (- grados-fahrenheit 32)))</code></pre>

<p>Y ahora ya podemos definir la función principal:</p>
<pre><code class="(null)">(define (convertir-temperatura grados tipo)
  (cond ((equal? tipo #\F) (list (a-grados-centigrados grados) &quot;grados centigrados&quot;))
        ((equal? tipo #\C) (list (a-grados-fahrenheit grados) &quot;grados fahrenheit&quot;))
        (else &quot;tipo de cambio incorrecto&quot;)))</code></pre>

<p>Por ejemplo:</p>
<pre><code class="(null)">(convertir-temperatura 50 #\F) ; =&gt; {10 &quot;grados centigrados&quot;}
(convertir-temperatura 50 #\C) ; =&gt; {122 &quot;grados fahrenheit&quot;}</code></pre>

<h3 id="funcióndisplay">Función <code>display</code></h3>

<p>Para imprimir por pantalla en Scheme se pude usar la función <code>display</code>, similar a la sentencia <code>print</code> de muchos otros lenguajes. Es necesario importar la librería <code>io simple</code>:</p>
<pre><code class="scheme">#lang r6rs
(import (rnrs base)
        (rnrs io simple))

(display &quot;\nHola mundo!\n&quot;)
(display &quot;La suma de 2 + 3 es: &quot;)
(display (+ 2 3))
(display &quot;\n&quot;)</code></pre>

<h3 id="pruebasunitariasenscheme">Pruebas unitarias en Scheme</h3>

<p>Para verificar que las funciones que definimos tienen un funcionamiento correcto, es decir, <em>&#8220;hacen lo que tienen que hacer&#8221;</em>, podemos diseñar distintos casos de prueba. Cada <strong>caso de prueba</strong> se caracteriza por unos datos de entrada de la función y por el resultado que esperamos que devuelva dicha función con esos valores de entrada.</p>

<p>Por ejemplo, en las pruebas de la función <em>convertir-temperatura</em>, hemos diseñado dos casos de prueba:</p>

<table>
<colgroup>
<col style="text-align:center;"/>
<col style="text-align:left;"/>
</colgroup>

<thead>
<tr>
	<th style="text-align:center;">Datos de Entrada</th>
	<th style="text-align:left;">Resultado Esperado</th>
</tr>
</thead>

<tbody>
<tr>
	<td style="text-align:center;">50 , #\F</td>
	<td style="text-align:left;">{10 &#8220;grados centigrados&#8221;}</td>
</tr>
<tr>
	<td style="text-align:center;">50 , #\C</td>
	<td style="text-align:left;">{122 &#8220;grados fahrenheit&#8221;}</td>
</tr>
</tbody>
</table>

<p>El resultado esperado a partir de unos valores concretos de entrada, se determina entendiendo <strong>qué</strong> debe hacer la función. Es decir, se obtiene a partir de la especificación del problema, antes de plantearnos <strong>cómo</strong> solucionarlo.</p>

<p>Os aconsejamos tener siempre presente la siguiente idea aunque resulte obvia:</p>

<blockquote>
<p>Para implementar una función, primero es <strong>imprescindible</strong> entender <strong>qué debe hacer la función</strong>. Después, seremos capaces de diseñar casos de prueba y ocuparnos de <strong>cómo implementarla</strong>.</p>
</blockquote>

<p>En las prácticas de la asignatura, para realizar pruebas usaremos el <strong>API SchemeUnit</strong>. Para ello, lo primero que tendremos que hacer es importar esta nueva librería. Por tanto, debemos añadir en nuestros ficheros de prácticas lo siguiente:</p>
<pre><code class="(null)">(import (rnrs base)
        (rnrs io simple)
        (schemeunit))  </code></pre>

<p>Una vez importada la librería, ya podemos hacer uso de algunas de sus funciones. En concreto, utilizaremos las siguientes:</p>

<ul>
<li><p><strong>check-true</strong></p>
<pre><code class="(null)">(check-true expr)   
;; Comprueba si su argumento es #t.
;; En caso contrario, se imprime un mensaje de error.</code></pre></li>
<li><p><strong>check-false</strong></p>
<pre><code class="(null)">(check-false expr)   
;; Comprueba si su argumento es #f.
;; En caso contrario, se imprime un mensaje de error.</code></pre></li>
<li><p><strong>check-equal?</strong></p>
<pre><code class="(null)">(check-equal? resultado-real resultado-esperado)   
;; Comprueba si sus dos argumentos son iguales.
;; En caso contrario, se imprime un mensaje de error.</code></pre></li>
</ul>

<p>Con las funciones <em>check-true</em> y <em>check-false</em> validaremos predicados (recuerda que en Scheme son funciones que devuelven un valor booleano) que hayamos implementado, comprobando si el resultado esperado es <em>true</em> o <em>false</em>, respectivamente.</p>

<p>Con la función <em>check-equal?</em> podremos validar si el resultado de la invocación a la función con unos determinados valores de entrada, representado por el argumento <em>resultado-real</em>, es igual al resultado que esperamos, dado por el argumento <em>resultado-esperado</em>.</p>

<h4 id="ejemplodepruebasdelafunciónecuaciondefinidaanteriormente">Ejemplo de pruebas de la función <strong>ecuacion</strong> definida anteriormente</h4>

<p>Las siguientes pruebas no mostrarán ningún mensaje de error, lo que significa que nuestra función <em>ecuacion</em> es &#8216;CORRECTA&#8217; para estas pruebas, es decir, que con los valores de entrada utilizados, su resultado se corresponde con el esperado.</p>
<pre><code class="(null)">(check-equal? (ecuacion 1 -5 6) (cons 3 2))
(check-equal? (ecuacion 2 -7 3) (cons 3 (/ 1 2)) )
(check-equal? (ecuacion -1 7 -10) (cons 2 5))  </code></pre>

<p>Ahora vamos a suponer que nos hemos equivocado en la definición de la función <em>ecuacion</em>, por ejemplo en el orden de los argumentos al invocar a la función auxiliar <em>raiz-pos</em>, en la llamada que se hace en la parte izquierda de la pareja resultante.</p>
<pre><code class="(null)">(define (ecuacion a b c)
	(cons (raiz-pos b a c) (raiz-neg a b c)))</code></pre>

<p>esta nueva definición, si ejecutamos la siguiente prueba:</p>
<pre><code class="(null)">(check-equal? (ecuacion 1 -5 6) (cons 3 2))</code></pre>

<p>el resultado será:</p>
<pre><code class="(null)">--------------------
FAILURE
actual:     {-1 . 2}
expected:   {3 . 2}
name:       check-equal?
location:   (#&lt;path:/.../filename.rkt&gt;)
expression: (check-equal? (ecuacion 1 -5 6) (cons 3 2))
--------------------</code></pre>

<p>Esta prueba muestra un mensaje de error, lo que significa que la nueva definición de <em>ecuacion</em> &#8216;FALLA&#8217;, es decir, que el resultado que devuelve <em>{&#8211;1 . 2}</em> no coincide con el resultado esperado <em>{3 . 2}</em>.</p>

<h2 id="ejercicios">Ejercicios</h2>

<h3 id="ejercicio1">Ejercicio 1</h3>

<p>Lanza DrRacket y escribe cada una de las siguientes instrucciones en el intérprete, intentado adivinar el resultado que va devolver. Están ordenadas por dificultad de arriba abajo y de izquierda a derecha. ¡¡Piensa en los resultados!!. Intenta entender cómo interpreta Scheme lo que escribes.</p>

<table>
<colgroup>
<col style="text-align:left;"/>
<col style="text-align:left;"/>
</colgroup>

<thead>
<tr>
	<th style="text-align:left;">Instrucción</th>
	<th style="text-align:left;">Instrucción</th>
</tr>
</thead>

<tbody>
<tr>
	<td style="text-align:left;">3</td>
	<td style="text-align:left;">(+ (- 4 (* 3 (/ 4 2) 4)) 3)</td>
</tr>
<tr>
	<td style="text-align:left;">(+ 1 2 )</td>
	<td style="text-align:left;">(* (+ (+ 2 3) 4) (* (* 3 3) 2))</td>
</tr>
<tr>
	<td style="text-align:left;">(+ 1 2 3 4)</td>
	<td style="text-align:left;">(* (+ 2 3 4 5) 3 (- 5 2 1))</td>
</tr>
<tr>
	<td style="text-align:left;">(+)</td>
	<td style="text-align:left;">(+ (- (+ (- (+ 2 3) 5) 1) 2) 3)</td>
</tr>
<tr>
	<td style="text-align:left;">(sqrt 25)</td>
	<td style="text-align:left;">(- (sqrt (* 5 ( + 3 2))) (+ 1 1 1 1))</td>
</tr>
<tr>
	<td style="text-align:left;">(* (+ 2 3) 5)</td>
	<td style="text-align:left;">(&gt; (* 3 (+ 2 (+ 3 1)) (+ 1 1)) (+ (* 2 2) 3))</td>
</tr>
<tr>
	<td style="text-align:left;">+</td>
	<td style="text-align:left;">(= (* 3 2) (+ 1 (+ 2 2) 1))</td>
</tr>
<tr>
	<td style="text-align:left;"><code>#\+</code></td>
	<td style="text-align:left;">(not (&gt; (+ 3 2) 5))</td>
</tr>
<tr>
	<td style="text-align:left;">&#8220;+&#8221;</td>
	<td style="text-align:left;">(and (even? 2) (odd? (+ 3 2)))</td>
</tr>
<tr>
	<td style="text-align:left;">“hola”</td>
	<td style="text-align:left;">(mod (+ 6 2) (+ 1 1))</td>
</tr>
</tbody>
</table>

<h3 id="ejercicio2">Ejercicio 2</h3>

<p>Predice lo que devolverá Scheme cuando escribas las siguientes expresiones. Están ordenadas por dificultad de arriba abajo y de izquierda a derecha. Después, pruébalas y comprueba si tu predicción era correcta. Si no lo era, intenta comprender por qué.</p>

<table>
<colgroup>
<col style="text-align:left;"/>
<col style="text-align:left;"/>
</colgroup>

<thead>
<tr>
	<th style="text-align:left;">Instrucción</th>
	<th style="text-align:left;">Instrucción</th>
</tr>
</thead>

<tbody>
<tr>
	<td style="text-align:left;">(equal? “hola” “hola”)</td>
	<td style="text-align:left;">(+ (char-&gt;integer(integer-&gt;char 1200))(char-&gt;integer #\A))</td>
</tr>
<tr>
	<td style="text-align:left;">(string-ref “pepe” 1)</td>
	<td style="text-align:left;">(string-length (make-string 7 #\E))</td>
</tr>
<tr>
	<td style="text-align:left;">(substring “buenos dias” 1 4)</td>
	<td style="text-align:left;">(define a 3) <br/> (define b (+ a 1))</td>
</tr>
<tr>
	<td style="text-align:left;">(= “hola” “hola”)</td>
	<td style="text-align:left;">(+ a b (* a b))</td>
</tr>
<tr>
	<td style="text-align:left;">(string-ref (substring “buenos dias 2 5) 1)</td>
	<td style="text-align:left;">(= a b)</td>
</tr>
<tr>
	<td style="text-align:left;">(define pi 3.14159)</td>
	<td style="text-align:left;">(if (and (&gt; a b) (&lt; b (* a b))) b a)</td>
</tr>
<tr>
	<td style="text-align:left;">pi</td>
	<td style="text-align:left;">(cond ((= a 4) 6) <br/> ((= b 4) (+ 6 7 a)) <br/> (else 25))</td>
</tr>
<tr>
	<td style="text-align:left;">“pi”</td>
	<td style="text-align:left;">(+ 2 (if (&gt; b a) b a))</td>
</tr>
<tr>
	<td style="text-align:left;">(+ pi (+ pi pi))</td>
	<td style="text-align:left;">(* (cond ((&gt; a b) a) <br/> ((&lt; a b) b) <br/>(else &#8211;1)) <br/> (+ a 1))</td>
</tr>
<tr>
	<td style="text-align:left;">(+ (* pi pi) (- 2 pi pi pi pi))</td>
	<td style="text-align:left;">((if (&lt; a b) + -) a b)</td>
</tr>
</tbody>
</table>

<h3 id="ejercicio3">Ejercicio 3</h3>

<p>Ejercicios con parejas. Predice lo que hace Scheme cuando escribas las siguientes expresiones. Están ordenadas por dificultad de arriba abajo y de izquierda a derecha. Después, pruébalas y comprueba si tu predicción era correcta. Si no lo era, intenta comprender por qué.</p>

<table>
<colgroup>
<col style="text-align:left;"/>
<col style="text-align:left;"/>
</colgroup>

<thead>
<tr>
	<th style="text-align:left;">Instrucción</th>
	<th style="text-align:left;">Instrucción</th>
</tr>
</thead>

<tbody>
<tr>
	<td style="text-align:left;">(cons 1 2)</td>
	<td style="text-align:left;">(car (cons (cons 3 4) 2))</td>
</tr>
<tr>
	<td style="text-align:left;">(car (cons 1 2))</td>
	<td style="text-align:left;">(cdr (cons (cons 3 4) 2))</td>
</tr>
<tr>
	<td style="text-align:left;">(cdr (cons 1 2))</td>
	<td style="text-align:left;">(cdr (cons 1 (cons 2 3)))</td>
</tr>
<tr>
	<td style="text-align:left;">(car (car (cons (cons 1 2) 3)))</td>
	<td style="text-align:left;">(cdr (car (cons (cons 1 2) 3)))</td>
</tr>
</tbody>
</table>

<h3 id="ejercicio4">Ejercicio 4</h3>

<p>Ejercicios con listas. Predice lo que hace Scheme cuando escribas las siguientes expresiones. Después, pruébalas y comprueba si tu predicción era correcta. Si no lo era, intenta comprender por qué.</p>

<table>
<colgroup>
<col style="text-align:left;"/>
<col style="text-align:left;"/>
</colgroup>

<thead>
<tr>
	<th style="text-align:left;">Instrucción</th>
	<th style="text-align:left;">Instrucción</th>
</tr>
</thead>

<tbody>
<tr>
	<td style="text-align:left;">'(1 2 3 4)</td>
	<td style="text-align:left;">(cons 3 '(1 2 3))</td>
</tr>
<tr>
	<td style="text-align:left;">(cdr '(1 2 3 4))</td>
	<td style="text-align:left;">(cdr (cons 8 (list 1 2 3 4)))</td>
</tr>
<tr>
	<td style="text-align:left;">(car '(1 2 3 4))</td>
	<td style="text-align:left;">(car (list (list 1 2) 1 2 3 4))</td>
</tr>
<tr>
	<td style="text-align:left;">'(1 (2 3) (4 (5)))</td>
	<td style="text-align:left;">(list 1 (list 2 3) (list 4 (list 5)))</td>
</tr>
<tr>
	<td style="text-align:left;">(car (cdr '(1 2 3 4)))</td>
	<td style="text-align:left;">(cons '(1 2 3) '(4 5 6))</td>
</tr>
<tr>
	<td style="text-align:left;">(cdr (cdr '(1 2 3 4)))</td>
	<td style="text-align:left;">(car (cdr (list 1 2 3 4)))</td>
</tr>
<tr>
	<td style="text-align:left;">(list 1 2 3 4)</td>
	<td style="text-align:left;">(cdr (cdr (list 1 2 3 4)))</td>
</tr>
</tbody>
</table>

<h3 id="ejercicio5">Ejercicio 5</h3>

<p>Los siguientes apartados intenta hacerlos sin utilizar el intérprete de Scheme.</p>

<p>a) Escribe una expresión diferente pero equivalente a la siguiente expresión:</p>

<pre><code>'(1 2 (7 8 (9 (10 (2 (3))))) 3 4)  
</code></pre>

<p>b) Dada la siguiente lista, indica la expresión correcta para que Scheme devuelva 5:</p>

<pre><code>'(1 2 3 4 5 6 7 8)
</code></pre>

<p>c) Dada la siguiente lista, indica la expresión correcta para que Scheme devuelva (8).</p>

<pre><code>'(1 2 3 4 5 6 7 8)
</code></pre>

<p>d) Dada la siguiente lista, indica la expresión correcta para que Scheme devuelva 8.</p>

<pre><code>'(1 2 3 4 5 6 7 8)
</code></pre>

<p>e) Dada la siguiente lista, indica la expresión correcta para que Scheme devuelva (3 4).</p>

<pre><code>'(1 2 (7 8 (9 (10 (2 (3))))) 3 4)  
</code></pre>

<p>f) Dada la siguiente lista, indica la expresión correcta para que Scheme devuelva 10.</p>

<pre><code>'(1 2 (7 8 (9 (10 (2 (3))))) 3 4)  
</code></pre>

<p>g) Dada la siguiente expresión, ¿qué devuelve Scheme?</p>

<pre><code>(cdr (cdr ‘(1 (2 3) (4 5) 6)))
</code></pre>

<p>h) Dada la siguiente expresión, ¿qué devuelve Scheme?</p>

<pre><code>(car (cdr (cdr ‘(1 (2 3) (4 5) 6))))
</code></pre>

<p>i) Dada la siguiente expresión, ¿qué devuelve Scheme?</p>

<pre><code>(cdr (cdr ‘(1 (2 3) 4 5)))
</code></pre>

<hr />

<p>Lenguajes y Paradigmas de Programación, curso 2015&#8211;16<br/>
© Departamento Ciencia de la Computación e Inteligencia Artificial, Universidad de Alicante<br/>
Cristina Pomares, Antonio Botía, Domingo Gallardo</p>
<div style="display:none">
<!--This seemingly unnecessary div markup is the only thing keeping this script working after Markdown conversion. Trust me.-->
 <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    
  });
</script>
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</div>
<script>(function(factory){if(typeof define==="function"&&define.amd){define("bidi_helpers",[],factory)}else{window.bidi_helpers=factory()}})(function(){var module={};module.Dir={RTL:-1,UNKNOWN:0,LTR:1};module.Format={LRE:"\u202A",RLE:"\u202B",PDF:"\u202C",LRM:"\u200E",RLM:"\u200F"};module.ltrChars_="A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02B8\u0300-\u0590\u0800-\u1FFF\u2C00-\uFB1C\uFE00-\uFE6F\uFEFD-\uFFFF";module.rtlChars_="\u0591-\u07FF\uFB1D-\uFDFF\uFE70-\uFEFC";module.ltrDirCheckRe_=new RegExp("^[^"+module.rtlChars_+"]*["+module.ltrChars_+"]");module.ltrCharReg_=new RegExp("["+module.ltrChars_+"]");module.hasAnyLtr=function(text){return module.ltrCharReg_.test(text)};module.rtlDirCheckRe_=new RegExp("^[^"+module.ltrChars_+"]*["+module.rtlChars_+"]");module.rtlRe=module.rtlDirCheckRe_;module.isRtlText=function(text){return module.rtlDirCheckRe_.test(text)};module.isLtrText=function(text){return module.ltrDirCheckRe_.test(text)};module.isRequiredLtrRe_=/^http:\/\/.*/;module.hasNumeralsRe_=/\d/;module.estimateDirection=function(text,detectionThreshold){var rtlCount=0;var totalCount=0;var hasWeaklyLtr=false;var tokens=text.split(/\s+/);for(var i=0;i<tokens.length;i++){var token=tokens[i];if(module.isRtlText(token)){rtlCount++;totalCount++}else{if(module.isRequiredLtrRe_.test(token)){hasWeaklyLtr=true}else{if(module.hasAnyLtr(token)){totalCount++}else{if(module.hasNumeralsRe_.test(token)){hasWeaklyLtr=true}}}}}return totalCount==0?(hasWeaklyLtr?module.Dir.LTR:module.Dir.UNKNOWN):(rtlCount/totalCount>detectionThreshold?module.Dir.RTL:module.Dir.LTR)};return module});(function(factory){if(typeof define==="function"&&define.amd){define("bidiweb",["bidi_helpers"],factory)}else{window.bidiweb=factory(bidi_helpers)}})(function(bidi_helpers){var module={};var IProcessor={makeRtl:function(element){},makeLtr:function(element){}};var css_processor=function(classes){return{makeRtl:function(element){element.classList.add(classes.rtl)},makeLtr:function(element){element.classList.add(classes.ltr)}}};var style_processor=function(falign){return{makeRtl:function(element){element.style.direction="rtl";if(falign){element.style.textAlign="right"}},makeLtr:function(element){element.style.direction="ltr";if(falign){element.style.textAlign="left"}}}};module.processors={css:css_processor,style:style_processor};var nodeListMock=function(node){var list=[node];list.item=function(i){return list[i]};return list};module.process=function(query,processor){var elements;if(query instanceof NodeList){elements=query}else{if(query instanceof Node){elements=nodeListMock(query)}else{elements=document.querySelectorAll(query)}}module.process_elements(elements,processor);return elements};module.process_elements=function(elements,processor){for(var index=0;index<elements.length;index++){var element=elements.item(index);var text=element.textContent||element.value||element.placeholder||"";var dir=bidi_helpers.estimateDirection(text,0.4);if(dir==bidi_helpers.Dir.RTL){processor.makeRtl(element)}else{if(dir==bidi_helpers.Dir.LTR){processor.makeLtr(element)}}}};module.process_css=function(query,classes){var proc=module.processors.css(classes);return module.process(query,proc)};module.process_style=function(query,falign){var proc=module.processors.style(falign);return module.process(query,proc)};module.style=function(query){return module.process_style(query,true)};module.css=function(query){return module.process_css(query,{rtl:"rtl",ltr:"ltr"})};module.htmlToElement=function(html){var container=document.createElement("div");container.innerHTML=html;return container};module.html_css=function(html){var container=module.htmlToElement(html);var nodes=container.querySelectorAll("*");module.css(nodes);return container.innerHTML};module.html_style=function(html){var container=module.htmlToElement(html);var nodes=container.querySelectorAll("*");module.style(nodes);return container.innerHTML};return module});</script>
<!-- ##END MARKED WRAPPER## -->
    </div>
</body>
</html>